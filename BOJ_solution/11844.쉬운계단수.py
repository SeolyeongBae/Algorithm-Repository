# 문제 유형 DP

# 좀 더 개선하는 방법 : 슬라이싱과 리스트 연산에 시간이 많이 소모되는 것으로 보여서, 바로 dp array로 접근해도 될 것 같다
# a1, a2를 한 이유는 맨 처음과 맨 마지막의 경우 양옆에 더한다는 개념이 모자라서였는데, 패딩(리스트 시작과 끝에 0)을 달아줬어도 좋을 듯..!!

# 1 <= n < = 100
n = int(input())
dp = []

dp.append([0] * 10)# 0~9의 개수
dp.append([0, 1, 1, 1, 1, 1, 1, 1, 1, 1])

'''
   0, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1
-----------------------------
1, 1, 2, 2, 2, 2, 2, 2, 2, 1

이렇게 shift 좌로하나 우로하나 시켰을때 그 합이 위와 같음!!
'''

if n == 1:
    print(9)
else:
    dp.append([1, 1, 2, 2, 2, 2, 2, 2, 2, 1]) # 맨 뒷자리에 앞자리보다 작은 수를 붙이거나 앞자리보다 큰 수를 붙임
    # 마지막 숫자-> 0이 1개, 9가 1개,

    # 0으로 시작하는 숫자는 1만을 가질 수 있음
    # 9로 시작하는 숫자는 8만을 가질 수 있음

    # 따라서 1~9이므로 dp[2] =  2 * 8 + 1 = 17이다.

    # 10 12 21 23 32 34 43 45 54 56 65 67 76 78 87 89 98
    # 끝나는 숫자의 특수성 -> 0과 9는 한개씩만 존재함. 1은 0이랑 2인데 0으로 시작할 수 없으므로 한개 존재함. 나머지는 2개씩 존재함.
    # 1~9가 한개씩 -> 0이 한개, 1이 한개, 2~8이 2개, 9가 1개

    for i in range(3, n+1):
        arr = [0] * 10
        a1 = [0] + dp[i-1][:9]
        a2 = dp[i-1][1:] + [0]
        for i in range(10):
            arr[i] = a1[i] + a2[i]
        dp.append(arr)

    print(sum(dp[n]) % ( 1000000000))
