# 문제 유형: DP
# 0부터 N까지 K개를 더해서 그 합이 N이 되는 경우의 수를 구하시오

# 덧셈의 순서가 바뀐 경우는 다른 경우로 센다.

# 많은 고민을 하게 만든 부분: 과연 이게 최적해가 맞는가? 직접 종이에 표를 그려 보면서도 표의 어떤 부분을 더해야 하는지 이해가 가질 않았다.
# 즉, 표의 다른 구성요소의 순서쌍에 변화를 줘서 더하는 것이라고 생각했다. (예시: 2는 1의 순서쌍을 2배하고, 1의 순서쌍끼리 랜덤으로 두개를 뽑아서 더한 값이다 -> 4에 적용 안됨)
# 하지만 점화식을 보장해주는 것은 순서쌍의 마지막 숫자가 무엇이냐는 것이다.
# 즉, dp[2][3] 은 dp[2][2] 의 순서쌍에서 맨 마지막 숫자에 0을 더한 것이다.
# 그리고 dp[1][2] 의 순서쌍 마지막에 1을 고정한 것과 같다.
# 마지막으로 dp[0][2] 의 순서쌍 마지막에 2을 고정한 것 같다.

# 따라서 배열의 각 요소를 더해도 겹치는 부분이 없고, 최적해의 합이 최적해가 된다!!

def sol(N ,K):

    dp = [[0 for _ in range(N+1)] for _ in range(K+1)]

    # dp[i] 은 k개의 숫자로 i를 만들 수 있는 가짓수이다.
    # 2차원 배열로 해야 할 것 같은 느낌이 든다.

    # 20을 3개의 수로 만드는 가짓수?
    # 19를 만드는 가짓수에서

    if K == 1 :
        return 1

    for i in range(N+1):
        dp[1][i] = 1

    for i in range(2, K+1):
        for j in range(N+1):
            #총 i개의 수로 j를 만드는 방법을 dp[j][i] 에 저장한다.
            for k in range(j+1):
                dp[i][j] += dp[i-1][k] #점화식
    return dp[K][N] % 1000000000


N, K = list(map(int, input().split()))
print(sol(N,K))