#계산 오르기 게임
#1번 계산 -> 2번 계단이나 3번 계단
#하지만 1번 -> 2번 -> 3번 계단을 밟을 순 없음.
#즉 1칸 2칸 으로 가고 다시 2칸 혹은 1칸

#오답노트: 마지막 발판을 밟아야 하는 조건을 부풀려 생각해서, 무조건 마지막 발판을 밟고 시작하도록 배열을 거꾸로 배치했음.
#그러나 dp[i]는 무조건 i-1번째 계단을 밟는다는 조건이기 때문에 마지막 계단을 결국은 밟게 됨... 너무 과하게 생각한 죄

def sol(s):

    #마지막 계단을 밟아야 하니까 거꾸로 가야 한다.

    #2칸을 이동 -> 1칸, 2칸 상관 없음
    #1칸을 이동 -> 무조건 다음은 2칸

    #근데, 여기서 무조건 큰 값으로 따라가면 그리디랑 다를 게 없지 않은가?
    #dp[i] = i번째 칸에서 얻을 수 있는 가장 큰 경우??

    #2차원 배열을 만들어서, 1번쨰 row에는 1칸 전진의 경우, 2번째 row는 2칸 전진의 경우를 만들어보자.
    # 윗줄: 앞에서 1칸 이동해서 도달했을 경우
    # 아랫줄: 앞에서 2칸 이동해서 도달했을 경우

    #라고 생각했지만!!! 1칸 + 2칸 그리고 오로지 2칸의 조합만 생각하면 되는 거였다.

    #틀렸다. 반례
    '''
    6
    123
    14
    3
    2
    13
    4
    '''

    #아 깨달았다!! 마지막 단계에 도달하지 못하는 케이스는 또 분류해야하는구나. -> 그럴 필요 없다.

    if len(s) == 1: return s[0]
    if len(s) == 2: return s[0] + s[1]
    if len(s) == 3: return max(s[0], s[1]) + s[2]

    dp = [s[0], s[0] + s[1], max(s[0], s[1]) + s[2]]

    for i in range(3, len(s)):
        dp.append(max(s[i-1] + dp[i-3], dp[i-2]) + s[i])

    #거꾸로 생각하면, 무조건 첫 칸을 밟아야 한다는 뜻
    return dp[-1]

num = int(input())
stairs = []
for _ in range(num):
    s = int(input())
    stairs.append(s)

print(sol(stairs))