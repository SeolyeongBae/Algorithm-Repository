# Note ; 오랜만에 알고리즘 문제를 풀게 되어 낯선 부분이 많았다.
# 중요한 점 1 : 메모장에 끄적여 봤을 때, 중복되는 경우가 많이 나오면 그걸 저장한다는 아이디어를 떠올리자
# 중요한 점 2 : 구하라고 하는 걸 잘 살펴보자. 제한 시간 안에 연산값을 구하는 건지, 혹은 '최소' '횟수'를 구하는 건지 꼭 체크하자.
# -> 피보나치와 비슷하다고 생각해서 풀고 있었는데, 떠올려 보니 값을 구하는 문제가 아니었다.

num = int(input())

dp = [0] * 1000001

#dp[i] : i를 만들 수 있는 최소 연산 횟수

for i in range (2, num+1):
    dp[i] = dp[i-1] + 1 # 1 빼는 경우
    if i % 3 == 0 :
        dp[i] = min( dp[i], dp[i//3] + 1)
    if i % 2 == 0 :
        dp[i] = min(dp[i], dp[i //2] + 1)
#틀렸던 이유 : if, elif를 사용했기 때문에 2로 나눴을 때 최소인지 검증할 수 없었다.
#MCM와 비슷한 맥락의 문제인 것 같다.
print(dp[num])
